{
  "language": "Solidity",
  "sources": {
    "contracts/CloneFactory.sol": {
      "content": "pragma solidity ^0.7.0;\n\n/// @notice https://github.com/optionality/clone-factory/blob/32782f82dfc5a00d103a7e61a17a5dedbd1e8e9d/contracts/CloneFactory.sol\n// SPDX-License-Identifier: MIT\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2018 Murray Software, LLC.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n//solhint-disable max-line-length\n//solhint-disable no-inline-assembly\n\ncontract CloneFactory {\n\n  function createClone(address target) internal returns (address result) {\n    bytes20 targetBytes = bytes20(target);\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(clone, 0x14), targetBytes)\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      result := create(0, clone, 0x37)\n    }\n  }\n\n  function isClone(address target, address query) internal view returns (bool result) {\n    bytes20 targetBytes = bytes20(target);\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\n      mstore(add(clone, 0xa), targetBytes)\n      mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n\n      let other := add(clone, 0x40)\n      extcodecopy(query, other, 0, 0x2d)\n      result := and(\n        eq(mload(clone), mload(other)),\n        eq(mload(add(clone, 0xd)), mload(add(other, 0xd)))\n      )\n    }\n  }\n}\n"
    },
    "contracts/DividendTokens.sol": {
      "content": "pragma solidity ^0.7.0;\n\n/// @notice DividendTokens to map [token] => [enabled]\n// SPDX-License-Identifier: GPLv2\nlibrary DividendTokens {\n    struct DividendToken {\n        uint timestamp;\n        uint index;\n        address token;\n        bool enabled;\n    }\n    struct Data {\n        bool initialised;\n        mapping(address => DividendToken) entries;\n        address[] index;\n    }\n\n    event DividendTokenAdded(address indexed token, bool enabled);\n    event DividendTokenRemoved(address indexed token);\n    event DividendTokenUpdated(address indexed token, bool enabled);\n\n    function init(Data storage self) internal {\n        require(!self.initialised);\n        self.initialised = true;\n    }\n    function add(Data storage self, address token, bool enabled) internal {\n        require(self.entries[token].timestamp == 0, \"DividendToken.add: Cannot add duplicate\");\n        self.index.push(token);\n        self.entries[token] = DividendToken(block.timestamp, self.index.length - 1, token, enabled);\n        emit DividendTokenAdded(token, enabled);\n    }\n    function remove(Data storage self, address token) internal {\n        require(self.entries[token].timestamp > 0, \"DividendToken.update: Address not registered\");\n        uint removeIndex = self.entries[token].index;\n        emit DividendTokenRemoved(token);\n        uint lastIndex = self.index.length - 1;\n        address lastIndexKey = self.index[lastIndex];\n        self.index[removeIndex] = lastIndexKey;\n        self.entries[lastIndexKey].index = removeIndex;\n        delete self.entries[token];\n        if (self.index.length > 0) {\n            self.index.pop();\n        }\n    }\n    function update(Data storage self, address token, bool enabled) internal {\n        DividendToken storage entry = self.entries[token];\n        require(entry.timestamp > 0, \"DividendToken.update: Address not registered\");\n        entry.timestamp = block.timestamp;\n        entry.enabled = enabled;\n        emit DividendTokenUpdated(token, enabled);\n    }\n    function length(Data storage self) internal view returns (uint) {\n        return self.index.length;\n    }\n}\n"
    },
    "contracts/ERC20.sol": {
      "content": "pragma solidity ^0.7.0;\n\n/// @notice ERC20 https://eips.ethereum.org/EIPS/eip-20 with optional symbol, name and decimals\n// SPDX-License-Identifier: GPLv2\ninterface ERC20 {\n    function totalSupply() external view returns (uint);\n    function balanceOf(address tokenOwner) external view returns (uint balance);\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\n    function transfer(address to, uint tokens) external returns (bool success);\n    function approve(address spender, uint tokens) external returns (bool success);\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\n\n    function symbol() external view returns (string memory);\n    function name() external view returns (string memory);\n    function decimals() external view returns (uint8);\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n"
    },
    "contracts/Greeter.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.7.1;\n\nimport \"@nomiclabs/buidler/console.sol\";\n\n\ncontract Greeter {\n  string greeting;\n\n  constructor(string memory _greeting) {\n    console.log(\"Deploying a Greeter with greeting:\", _greeting);\n    greeting = _greeting;\n  }\n\n  function greet() public view returns (string memory) {\n    return greeting;\n  }\n\n  function setGreeting(string memory _greeting) public {\n    console.log(\"Changing greeting from '%s' to '%s'\", greeting, _greeting);\n    greeting = _greeting;\n  }\n}\n"
    },
    "@nomiclabs/buidler/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.8.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logByte(byte p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(byte)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/Migrations.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.8.0;\n\ncontract Migrations {\n  address public owner = msg.sender;\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    require(\n      msg.sender == owner,\n      \"This function is restricted to the contract's owner\"\n    );\n    _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n}\n"
    },
    "contracts/OGDToken.sol": {
      "content": "pragma solidity ^0.7.0;\n// pragma experimental ABIEncoderV2;\n\n// Use prefix \"./\" normally and \"https://github.com/ogDAO/Governance/blob/master/contracts/\" in Remix\nimport \"./Permissioned.sol\";\nimport \"./OGDTokenInterface.sol\";\nimport \"./DividendTokens.sol\";\n\n\n/// @notice Optino Governance Dividend Token = ERC20 + mint + burn + dividend payments. (c) The Optino Project 2020\n// SPDX-License-Identifier: GPLv2\ncontract OGDToken is OGDTokenInterface, Permissioned {\n    using SafeMath for uint;\n    using DividendTokens for DividendTokens.Data;\n    using DividendTokens for DividendTokens.DividendToken;\n\n    struct Account {\n      uint balance;\n      mapping(address => uint) lastDividendPoints;\n      mapping(address => uint) owing;\n    }\n\n    string _symbol;\n    string  _name;\n    uint8 _decimals;\n    uint _totalSupply;\n    mapping(address => Account) accounts;\n    mapping(address => mapping(address => uint)) allowed;\n\n    DividendTokens.Data private dividendTokens;\n\n    uint public constant pointMultiplier = 10e27;\n    mapping(address => uint) public totalDividendPoints;\n    mapping(address => uint) public unclaimedDividends;\n\n    event UpdateAccountInfo(address dividendToken, address account, uint owing, uint totalOwing, uint lastDividendPoints, uint totalDividendPoints, uint unclaimedDividends);\n    event DividendDeposited(address indexed token, uint tokens);\n    event DividendWithdrawn(address indexed account, address indexed token, uint tokens);\n\n    // Duplicated from the library for ABI generation\n    event DividendTokenAdded(address indexed token, bool enabled);\n    event DividendTokenRemoved(address indexed token);\n    event DividendTokenUpdated(address indexed token, bool enabled);\n\n    constructor(string memory symbol, string memory name, uint8 decimals, address tokenOwner, uint initialSupply) {\n        initPermissioned(msg.sender);\n        _symbol = symbol;\n        _name = name;\n        _decimals = decimals;\n        accounts[tokenOwner].balance = initialSupply;\n        _totalSupply = initialSupply;\n        emit Transfer(address(0), tokenOwner, _totalSupply);\n    }\n    function symbol() override external view returns (string memory) {\n        return _symbol;\n    }\n    function name() override external view returns (string memory) {\n        return _name;\n    }\n    function decimals() override external view returns (uint8) {\n        return _decimals;\n    }\n    function totalSupply() override external view returns (uint) {\n        return _totalSupply.sub(accounts[address(0)].balance);\n    }\n    function balanceOf(address tokenOwner) override external view returns (uint balance) {\n        return accounts[tokenOwner].balance;\n    }\n    function transfer(address to, uint tokens) override external returns (bool success) {\n        updateAccounts(msg.sender, to);\n        accounts[msg.sender].balance = accounts[msg.sender].balance.sub(tokens);\n        accounts[to].balance = accounts[to].balance.add(tokens);\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n    function approve(address spender, uint tokens) override external returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n    function transferFrom(address from, address to, uint tokens) override external returns (bool success) {\n        updateAccounts(msg.sender, to);\n        accounts[from].balance = accounts[from].balance.sub(tokens);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n        accounts[to].balance = accounts[to].balance.add(tokens);\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n    function allowance(address tokenOwner, address spender) override external view returns (uint remaining) {\n        return allowed[tokenOwner][spender];\n    }\n\n    function addDividendToken(address _dividendToken) external onlyOwner {\n        if (!dividendTokens.initialised) {\n            dividendTokens.init();\n        }\n        dividendTokens.add(_dividendToken, true);\n    }\n    function updateDividendToken(address token, bool enabled) public onlyOwner {\n        require(dividendTokens.initialised);\n        dividendTokens.update(token, enabled);\n    }\n    function removeDividendToken(address token) public onlyOwner {\n        require(dividendTokens.initialised);\n        dividendTokens.remove(token);\n    }\n    function getDividendTokenByIndex(uint i) public view returns (address, bool) {\n        require(i < dividendTokens.length(), \"Invalid dividend token index\");\n        DividendTokens.DividendToken memory dividendToken = dividendTokens.entries[dividendTokens.index[i]];\n        return (dividendToken.token, dividendToken.enabled);\n    }\n    function dividendTokensLength() public view returns (uint) {\n        return dividendTokens.length();\n    }\n\n    /// @notice New dividends owing since the last updateAccount(...)\n    function newDividendsOwing(address dividendToken, address account) internal view returns (uint) {\n        uint newDividendPoints = totalDividendPoints[dividendToken].sub(accounts[account].lastDividendPoints[dividendToken]);\n        return accounts[account].balance.mul(newDividendPoints).div(pointMultiplier);\n    }\n    /// @notice Dividends owning since the last updateAccount(...) + new dividends owing since the last updateAccount(...)\n    function dividendsOwing(address account) public view returns (address[] memory tokenList, uint[] memory owingList) {\n        tokenList = new address[](dividendTokens.index.length);\n        owingList = new uint[](dividendTokens.index.length);\n        for (uint i = 0; i < dividendTokens.index.length; i++) {\n            DividendTokens.DividendToken memory dividendToken = dividendTokens.entries[dividendTokens.index[i]];\n            uint owing = accounts[account].owing[dividendToken.token].add(newDividendsOwing(dividendToken.token, account));\n            tokenList[i] = dividendToken.token;\n            owingList[i] = owing;\n        }\n    }\n    function updateAccounts(address account1, address account2) internal {\n        for (uint i = 0; i < dividendTokens.index.length; i++) {\n            DividendTokens.DividendToken memory dividendToken = dividendTokens.entries[dividendTokens.index[i]];\n            if (dividendToken.enabled) {\n                uint owing = newDividendsOwing(dividendToken.token, account1);\n                if (owing > 0) {\n                    unclaimedDividends[dividendToken.token] = unclaimedDividends[dividendToken.token].sub(owing);\n                    accounts[account1].lastDividendPoints[dividendToken.token] = totalDividendPoints[dividendToken.token];\n                    accounts[account1].owing[dividendToken.token] = accounts[account1].owing[dividendToken.token].add(owing);\n                }\n                if (account1 != account2) {\n                    owing = newDividendsOwing(dividendToken.token, account2);\n                    if (owing > 0) {\n                        unclaimedDividends[dividendToken.token] = unclaimedDividends[dividendToken.token].sub(owing);\n                        accounts[account2].lastDividendPoints[dividendToken.token] = totalDividendPoints[dividendToken.token];\n                        accounts[account2].owing[dividendToken.token] = accounts[account2].owing[dividendToken.token].add(owing);\n                    }\n                }\n            }\n        }\n    }\n\n    /// @notice Deposit enabled dividend token\n    function depositDividend(address token, uint tokens) public payable {\n        DividendTokens.DividendToken memory _dividendToken = dividendTokens.entries[token];\n        require(_dividendToken.enabled, \"Dividend token is not enabled\");\n        totalDividendPoints[token] = totalDividendPoints[token].add(tokens.mul(pointMultiplier).div(_totalSupply));\n        unclaimedDividends[token] = unclaimedDividends[token].add(tokens);\n        if (token == address(0)) {\n            require(msg.value >= tokens, \"Insufficient ETH sent\");\n            uint refund = msg.value.sub(tokens);\n            if (refund > 0) {\n                require(msg.sender.send(refund), \"ETH refund failure\");\n            }\n        } else {\n            require(ERC20(token).transferFrom(msg.sender, address(this), tokens), \"ERC20 transferFrom failure\");\n        }\n        emit DividendDeposited(token, tokens);\n    }\n    /// @notice Received ETH as dividends\n    receive () external payable {\n        depositDividend(address(0), msg.value);\n    }\n\n    function withdrawDividendsFor(address account) internal {\n        updateAccounts(account, account);\n        for (uint i = 0; i < dividendTokens.index.length; i++) {\n            DividendTokens.DividendToken memory dividendToken = dividendTokens.entries[dividendTokens.index[i]];\n            if (dividendToken.enabled) {\n                uint tokens = accounts[account].owing[dividendToken.token];\n                if (tokens > 0) {\n                    accounts[account].owing[dividendToken.token] = 0;\n                    if (dividendToken.token == address(0)) {\n                        require(payable(account).send(tokens), \"ETH send failure\");\n                    } else {\n                        require(ERC20(dividendToken.token).transfer(account, tokens), \"ERC20 transfer failure\");\n                    }\n                }\n                emit DividendWithdrawn(account, dividendToken.token, tokens);\n            }\n        }\n    }\n    /// @notice Withdraw enabled dividends tokens\n    function withdrawDividends() public {\n        withdrawDividendsFor(msg.sender);\n    }\n    /// @notice Withdraw enabled and disabled dividends tokens. Does not include new dividends since last updateAccount(...) triggered by transfer(...) and transferFrom(...)\n    function withdrawDividend(address token) public {\n        uint tokens = accounts[msg.sender].owing[token];\n        if (tokens > 0) {\n            accounts[msg.sender].owing[token] = 0;\n            if (token == address(0)) {\n                require(payable(msg.sender).send(tokens), \"ETH send failure\");\n            } else {\n                require(ERC20(token).transfer(msg.sender, tokens), \"ERC20 transfer failure\");\n            }\n        }\n        emit DividendWithdrawn(msg.sender, token, tokens);\n    }\n\n    /// @notice Mint tokens\n    function mint(address tokenOwner, uint tokens) override external permitted(ROLE_MINTER, tokens) returns (bool success) {\n        processed(ROLE_MINTER, tokens);\n        accounts[tokenOwner].balance = accounts[tokenOwner].balance.add(tokens);\n        _totalSupply = _totalSupply.add(tokens);\n        emit Transfer(address(0), tokenOwner, tokens);\n        updateAccounts(tokenOwner, tokenOwner);\n        return true;\n    }\n    /// @notice Withdraw dividends and then burn tokens\n    function burn(uint tokens) override external returns (bool success) {\n        updateAccounts(msg.sender, msg.sender);\n        withdrawDividendsFor(msg.sender);\n        accounts[msg.sender].balance = accounts[msg.sender].balance.sub(tokens);\n        _totalSupply = _totalSupply.sub(tokens);\n        emit Transfer(msg.sender, address(0), tokens);\n        return true;\n    }\n\n    /// @notice Recover tokens for non enabled dividend tokens\n    function recoverTokens(address token, uint tokens) public onlyOwner {\n        DividendTokens.DividendToken memory dividendToken = dividendTokens.entries[token];\n        require(dividendToken.timestamp == 0 || !dividendToken.enabled, \"Cannot recover tokens for enabled dividend token\");\n        if (token == address(0)) {\n            require(payable(owner).send((tokens == 0 ? address(this).balance : tokens)), \"ETH send failure\");\n        } else {\n            require(ERC20(token).transfer(owner, tokens == 0 ? ERC20(token).balanceOf(address(this)) : tokens), \"ERC20 transfer failure\");\n        }\n    }\n}\n"
    },
    "contracts/Permissioned.sol": {
      "content": "pragma solidity ^0.7.0;\n\nimport \"./Owned.sol\";\nimport \"./SafeMath.sol\";\n\n/// @notice Permissioned\n// SPDX-License-Identifier: GPLv2\ncontract Permissioned is Owned {\n    using SafeMath for uint;\n\n    struct Permission {\n        bool active;\n        uint maximum;\n        uint processed;\n    }\n\n    uint public constant ROLE_MINTER = 1;\n    // Don't need ROLE_BURNER at the moment\n    // uint public constant ROLE_BURNER = 2;\n    mapping(address => mapping(uint => Permission)) public permissions;\n\n    event PermissionUpdated(address indexed account, uint role, bool active, uint maximum, uint processed);\n\n    modifier permitted(uint role, uint tokens) {\n        Permission storage permission = permissions[msg.sender][role];\n        require(permission.active && (permission.maximum == 0 || permission.processed + tokens < permission.maximum), \"Not permissioned\");\n        permission.processed = permission.processed.add(tokens);\n        _;\n    }\n\n    function initPermissioned(address _owner) internal {\n        initOwned(_owner);\n        // setPermission(_owner, ROLE_MINTER, true, 0);\n        // setPermission(_owner, ROLE_BURNER, true, 0);\n    }\n    function setPermission(address account, uint role, bool active, uint maximum) public onlyOwner {\n        uint processed = permissions[account][role].processed;\n        permissions[account][role] = Permission({ active: active, maximum: maximum, processed: processed });\n        emit PermissionUpdated(account, role, active, maximum, processed);\n    }\n    function processed(uint role, uint tokens) internal {\n        permissions[msg.sender][role].processed = permissions[msg.sender][role].processed.add(tokens);\n    }\n}\n"
    },
    "contracts/Owned.sol": {
      "content": "pragma solidity ^0.7.0;\n\n/// @notice Ownership\n// SPDX-License-Identifier: GPLv2\ncontract Owned {\n    bool initialised;\n    address public owner;\n\n    event OwnershipTransferred(address indexed from, address indexed to);\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    function initOwned(address _owner) internal {\n        require(!initialised, \"Already initialised\");\n        owner = address(uint160(_owner));\n        initialised = true;\n    }\n    function transferOwnership(address _newOwner) public onlyOwner {\n        emit OwnershipTransferred(owner, _newOwner);\n        owner = _newOwner;\n    }\n}\n"
    },
    "contracts/SafeMath.sol": {
      "content": "pragma solidity ^0.7.0;\n\n/// @notice Safe maths\n// SPDX-License-Identifier: GPLv2\nlibrary SafeMath {\n    function add(uint a, uint b) internal pure returns (uint c) {\n        c = a + b;\n        require(c >= a, \"Add overflow\");\n    }\n    function sub(uint a, uint b) internal pure returns (uint c) {\n        require(b <= a, \"Sub underflow\");\n        c = a - b;\n    }\n    function mul(uint a, uint b) internal pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b, \"Mul overflow\");\n    }\n    function div(uint a, uint b) internal pure returns (uint c) {\n        require(b > 0, \"Divide by 0\");\n        c = a / b;\n    }\n}\n"
    },
    "contracts/OGDTokenInterface.sol": {
      "content": "pragma solidity ^0.7.0;\n\nimport \"./ERC20.sol\";\n\n/// @notice OGDTokenInterface = ERC20 + mint + burn (+ dividend payment)\n// SPDX-License-Identifier: GPLv2\ninterface OGDTokenInterface is ERC20 {\n    function mint(address tokenOwner, uint tokens) external returns (bool success);\n    function burn(uint tokens) external returns (bool success);\n    // function burnFrom(address tokenOwner, uint tokens) external returns (bool success);\n}\n"
    },
    "contracts/OGToken.sol": {
      "content": "pragma solidity ^0.7.0;\n\n// Use prefix \"./\" normally and \"https://github.com/ogDAO/Governance/blob/master/contracts/\" in Remix\nimport \"./Permissioned.sol\";\nimport \"./OGTokenInterface.sol\";\n\n\n/// @notice Optino Governance Token = ERC20 + mint + burn. (c) The Optino Project 2020\n// SPDX-License-Identifier: GPLv2\ncontract OGToken is OGTokenInterface, Permissioned {\n    using SafeMath for uint;\n\n    struct Stake {\n        uint dataType;\n        address[4] addresses;\n        uint[6] uints;\n        string[4] strings;\n    }\n\n    struct Account {\n      uint balance;\n      uint locked;\n      uint staked;\n      uint end;\n      mapping(bytes32 => uint) stakes;\n      // mapping(address => uint) lastDividendPoints;\n      // mapping(address => uint) owing;\n    }\n\n    string _symbol;\n    string  _name;\n    uint8 _decimals;\n    uint _totalSupply;\n    mapping(address => Account) accounts;\n\n    mapping(address => mapping(address => uint)) allowed;\n    uint public cap;\n    bool public freezeCap;\n\n    mapping(bytes32 => Stake) public stakeInfoData;\n    bytes32[] public stakeInfoIndex;\n\n    // uint public maxDividendTokens = 20;\n    // mapping(address => bool) public dividendTokens;\n    // address[] public dividendTokenIndex;\n    // uint public constant pointMultiplier = 10e18;\n    // mapping(address => uint) public totalDividendPoints;\n    // mapping(address => uint) public unclaimedDividends;\n\n    event CapUpdated(uint256 cap, bool freezeCap);\n    // event MaxDividendTokensUpdated(uint256 maxDividendTokens);\n    // event DividendTokensAdded(address dividendToken);\n    event LogInfo(string topic, uint number, bytes32 data, string note, address addr);\n    // event UpdateAccountInfo(address dividendToken, address account, uint owing, uint totalOwing, uint lastDividendPoints, uint totalDividendPoints, uint unclaimedDividends);\n\n    constructor(string memory symbol, string memory name, uint8 decimals, address tokenOwner, uint initialSupply) {\n        initPermissioned(msg.sender);\n        _symbol = symbol;\n        _name = name;\n        _decimals = decimals;\n        accounts[tokenOwner].balance = initialSupply;\n        _totalSupply = initialSupply;\n        emit Transfer(address(0), tokenOwner, _totalSupply);\n    }\n    function symbol() override external view returns (string memory) {\n        return _symbol;\n    }\n    function name() override external view returns (string memory) {\n        return _name;\n    }\n    function decimals() override external view returns (uint8) {\n        return _decimals;\n    }\n    function totalSupply() override external view returns (uint) {\n        return _totalSupply.sub(accounts[address(0)].balance);\n    }\n    function balanceOf(address tokenOwner) override external view returns (uint balance) {\n        return accounts[tokenOwner].balance;\n    }\n    function transfer(address to, uint tokens) override external returns (bool success) {\n        // for (uint i = 0; i < dividendTokenIndex.length; i++) {\n        //     address dividendToken = dividendTokenIndex[i];\n        //     updateAccount(dividendToken, msg.sender);\n        //     updateAccount(dividendToken, to);\n        // }\n        accounts[msg.sender].balance = accounts[msg.sender].balance.sub(tokens);\n        accounts[to].balance = accounts[to].balance.add(tokens);\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n    function approve(address spender, uint tokens) override external returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n    function transferFrom(address from, address to, uint tokens) override external returns (bool success) {\n        // for (uint i = 0; i < dividendTokenIndex.length; i++) {\n        //     address dividendToken = dividendTokenIndex[i];\n        //     updateAccount(dividendToken, msg.sender);\n        //     updateAccount(dividendToken, to);\n        // }\n        accounts[from].balance = accounts[from].balance.sub(tokens);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n        accounts[to].balance = accounts[to].balance.add(tokens);\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n    function allowance(address tokenOwner, address spender) override external view returns (uint remaining) {\n        return allowed[tokenOwner][spender];\n    }\n\n    function setCap(uint _cap, bool _freezeCap) external onlyOwner {\n        require(!freezeCap, \"Cap frozen\");\n        (cap, freezeCap) = (_cap, _freezeCap);\n        emit CapUpdated(cap, freezeCap);\n    }\n    /*\n    function setMaxDividendTokens(uint _maxDividendTokens) external onlyOwner {\n        require(_maxDividendTokens > dividendTokenIndex.length, \"Max must be more than current list length\");\n        maxDividendTokens = _maxDividendTokens;\n        emit MaxDividendTokensUpdated(maxDividendTokens);\n    }\n    */\n    /*\n    function addDividendToken(address _dividendToken) external onlyOwner {\n        require(!dividendTokens[_dividendToken], \"Token already in the list\");\n        dividendTokens[_dividendToken] = true;\n        dividendTokenIndex.push(_dividendToken);\n        emit DividendTokensAdded(_dividendToken);\n    }\n    */\n\n    /*\n    function disburse(uint amount) {\n      totalDividendPoints += (amount * pointsMultiplier / totalSupply);\n      totalSupply += amount;\n      unclaimedDividends += amount;\n    }*/\n    /*\n    function dividendsOwing(address dividendToken, address account) public view returns (uint) {\n        uint newDividendPoints = totalDividendPoints[dividendToken] - accounts[account].lastDividendPoints[dividendToken];\n        return (accounts[account].balance * newDividendPoints) / pointMultiplier;\n    }\n    */\n    /*\n    function updateAccount(address dividendToken, address account) internal {\n        uint owing = dividendsOwing(dividendToken, account);\n        // emit LogInfo(\"updateAccount: owing\", owing, 0x0, \"\", account);\n        if (owing > 0) {\n            // emit LogInfo(\"updateAccount: _unclaimedDividends before\", unclaimedDividends[dividendToken], 0x0, \"\", account);\n            unclaimedDividends[dividendToken] = unclaimedDividends[dividendToken].sub(owing);\n            // emit LogInfo(\"updateAccount: _unclaimedDividends after\", unclaimedDividends[dividendToken], 0x0, \"\", account);\n            // // emit LogInfo(\"updateAccount: accounts[account].balance\", accounts[account].balance, 0x0, \"\", account);\n            // // accounts[account][dividendToken].balance = accounts[account][dividendToken].balance.add(owing);\n            // // emit LogInfo(\"updateAccount: accounts[account][dividendToken].balance\", accounts[account][dividendToken].balance, 0x0, \"\", account);\n            // emit LogInfo(\"updateAccount: accounts[account].lastDividendPoints[dividendToken] before\", accounts[account].lastDividendPoints[dividendToken], 0x0, \"\", account);\n            accounts[account].lastDividendPoints[dividendToken] = totalDividendPoints[dividendToken];\n            // emit LogInfo(\"updateAccount: accounts[account].lastDividendPoints[dividendToken] after\", accounts[account].lastDividendPoints[dividendToken], 0x0, \"\", account);\n            accounts[account].owing[dividendToken] = accounts[account].owing[dividendToken].add(owing);\n        }\n        // emit UpdateAccountInfo(dividendToken, account, owing, accounts[account].owing[dividendToken], accounts[account].lastDividendPoints[dividendToken], totalDividendPoints[dividendToken], unclaimedDividends[dividendToken]);\n    }\n    */\n    /*\n    function depositDividends(address dividendToken, uint dividends) public {\n        // emit LogInfo(\"depositDividends: dividendToken\", 0, 0x0, \"\", dividendToken);\n        // emit LogInfo(\"depositDividends: dividends\", dividends, 0x0, \"\", address(0));\n        // emit LogInfo(\"depositDividends: pointMultiplier\", pointMultiplier, 0x0, \"\", address(0));\n        // emit LogInfo(\"depositDividends: _totalSupply\", _totalSupply, 0x0, \"\", address(0));\n        totalDividendPoints[dividendToken] = totalDividendPoints[dividendToken].add((dividends * pointMultiplier / _totalSupply));\n        unclaimedDividends[dividendToken] = unclaimedDividends[dividendToken].add(dividends);\n        // emit LogInfo(\"depositDividends: totalDividendPoints[dividendToken]\", totalDividendPoints[dividendToken], 0x0, \"\", address(0));\n        // emit LogInfo(\"depositDividends: unclaimedDividends[dividendToken]\", unclaimedDividends[dividendToken], 0x0, \"\", address(0));\n        ERC20(dividendToken).transferFrom(msg.sender, address(this), dividends);\n    }\n    */\n    /*\n    function withdrawDividends(address dividendToken) public returns (uint withdrawn) {\n        updateAccount(dividendToken, msg.sender);\n        withdrawn = 0;\n    }\n    */\n    function mint(address tokenOwner, uint tokens) override external permitted(ROLE_MINTER, tokens) returns (bool success) {\n        require(cap == 0 || _totalSupply + tokens <= cap, \"Cap exceeded\");\n        processed(ROLE_MINTER, tokens);\n        accounts[tokenOwner].balance = accounts[tokenOwner].balance.add(tokens);\n        _totalSupply = _totalSupply.add(tokens);\n        emit Transfer(address(0), tokenOwner, tokens);\n        // for (uint i = 0; i < dividendTokenIndex.length; i++) {\n        //     updateAccount(dividendTokenIndex[i], tokenOwner);\n        // }\n        return true;\n    }\n    function burn(uint tokens) override external returns (bool success) {\n        // for (uint i = 0; i < dividendTokenIndex.length; i++) {\n        //     updateAccount(dividendTokenIndex[i], msg.sender);\n        // }\n        // TODO Pay out\n        accounts[msg.sender].balance = accounts[msg.sender].balance.sub(tokens);\n        _totalSupply = _totalSupply.sub(tokens);\n        emit Transfer(msg.sender, address(0), tokens);\n        return true;\n    }\n    // function burnFrom(address tokenOwner, uint tokens) override external returns (bool success) {\n    //     for (uint i = 0; i < dividendTokenIndex.length; i++) {\n    //         updateAccount(dividendTokenIndex[i], tokenOwner);\n    //     }\n    //     // TODO Pay out\n    //     allowed[tokenOwner][msg.sender] = allowed[tokenOwner][msg.sender].sub(tokens);\n    //     accounts[tokenOwner].balance = accounts[tokenOwner].balance.sub(tokens);\n    //     _totalSupply = _totalSupply.sub(tokens);\n    //     emit Transfer(tokenOwner, address(0), tokens);\n    //     return true;\n    // }\n}\n"
    },
    "contracts/OGTokenInterface.sol": {
      "content": "pragma solidity ^0.7.0;\n\nimport \"./ERC20.sol\";\n\n/// @notice OGTokenInterface = ERC20 + mint + burn\n// SPDX-License-Identifier: GPLv2\ninterface OGTokenInterface is ERC20 {\n    function mint(address tokenOwner, uint tokens) external returns (bool success);\n    function burn(uint tokens) external returns (bool success);\n    // function burnFrom(address tokenOwner, uint tokens) external returns (bool success);\n}\n"
    },
    "contracts/OptinoGov.sol": {
      "content": "pragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\n// Use prefix \"./\" normally and \"https://github.com/ogDAO/Governance/blob/master/contracts/\" in Remix\nimport \"./OGTokenInterface.sol\";\nimport \"./OGDTokenInterface.sol\";\nimport \"./SafeMath.sol\";\n\n\n/// @notice Optino Governance config\ncontract OptinoGovConfig {\n    using SafeMath for uint;\n\n    uint constant SECONDS_PER_YEAR = 10000; // Testing 24 * 60 * 60 * 365;\n\n    OGTokenInterface public ogToken;\n    OGDTokenInterface public ogdToken;\n    uint public maxDuration = 10000 seconds; // Testing 365 days;\n    uint public rewardsPerSecond = 150_000_000_000_000_000; // 0.15\n    uint public collectRewardForFee = 5 * 10**16; // 5%, 18 decimals\n    uint public collectRewardForDelay = 1 seconds; // Testing 7 days\n    uint public proposalCost = 100_000_000_000_000_000_000; // 100 tokens assuming 18 decimals\n    uint public proposalThreshold = 1 * 10**15; // 0.1%, 18 decimals\n    uint public quorum = 2 * 10 ** 17; // 20%, 18 decimals\n    uint public quorumDecayPerSecond = 4 * 10**17 / uint(60 * 60 * 24 * 365); // 40% per year, i.e., 0 in 6 months\n    uint public votingDuration = 10 seconds; // 3 days;\n    uint public executeDelay = 10 seconds; // 2 days;\n    uint public rewardPool = 1_000_000 * 10**18;\n    uint public totalVotes;\n\n    /*\n    event MaxDurationUpdated(uint maxDuration);\n    event RewardsPerSecondUpdated(uint rewardsPerSecond);\n    event CollectRewardForFeeUpdated(uint collectRewardForFee);\n    event CollectRewardForDelayUpdated(uint collectRewardForDelay);\n    event ProposalCostUpdated(uint proposalCost);\n    event ProposalThresholdUpdated(uint proposalThreshold);\n    event QuorumUpdated(uint quorum);\n    event QuorumDecayPerSecondUpdated(uint quorumDecayPerSecond);\n    event VotingDurationUpdated(uint votingDuration);\n    event ExecuteDelayUpdated(uint executeDelay);\n    */\n    event ConfigUpdated(string key, uint value);\n\n    modifier onlySelf {\n        require(msg.sender == address(this), \"Not self\");\n        _;\n    }\n\n    constructor(OGTokenInterface _ogToken, OGDTokenInterface _ogdToken) {\n        ogToken = _ogToken;\n        ogdToken = _ogdToken;\n    }\n\n    function equalString(string memory s1, string memory s2) internal pure returns(bool) {\n        return keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2));\n    }\n    function setConfig(string memory key, uint value) external onlySelf {\n        if (equalString(key, \"maxDuration\")) {\n            maxDuration = value;\n        } else if (equalString(key, \"collectRewardForFee\")) {\n            collectRewardForFee = value;\n        } else if (equalString(key, \"collectRewardForDelay\")) {\n            collectRewardForDelay = value;\n        } else if (equalString(key, \"rewardsPerSecond\")) {\n            rewardsPerSecond = value;\n        } else if (equalString(key, \"proposalCost\")) {\n            proposalCost = value;\n        } else if (equalString(key, \"proposalThreshold\")) {\n            proposalThreshold = value;\n        } else if (equalString(key, \"quorum\")) {\n            quorum = value;\n        } else if (equalString(key, \"quorumDecayPerSecond\")) {\n            quorumDecayPerSecond = value;\n        } else if (equalString(key, \"votingDuration\")) {\n            votingDuration = value;\n        } else if (equalString(key, \"executeDelay\")) {\n            executeDelay = value;\n        } else {\n            revert(\"Invalid key\");\n        }\n        emit ConfigUpdated(key, value);\n    }\n    /*\n    function setMaxDuration(uint _maxDuration) external onlySelf {\n        maxDuration = _maxDuration;\n        emit MaxDurationUpdated(maxDuration);\n    }\n    function setCollectRewardForFee(uint _collectRewardForFee) external onlySelf {\n        collectRewardForFee = _collectRewardForFee;\n        emit CollectRewardForFeeUpdated(collectRewardForFee);\n    }\n    function setCollectRewardForDelay(uint _collectRewardForDelay) external onlySelf {\n        collectRewardForDelay = _collectRewardForDelay;\n        emit CollectRewardForDelayUpdated(collectRewardForDelay);\n    }\n    function setRewardsPerSecond(uint _rewardsPerSecond) external onlySelf {\n        rewardsPerSecond = _rewardsPerSecond;\n        emit RewardsPerSecondUpdated(rewardsPerSecond);\n    }\n    function setProposalCost(uint _proposalCost) external onlySelf {\n        proposalCost = _proposalCost;\n        emit ProposalCostUpdated(proposalCost);\n    }\n    function setProposalThreshold(uint _proposalThreshold) external onlySelf {\n        proposalThreshold = _proposalThreshold;\n        emit ProposalThresholdUpdated(proposalThreshold);\n    }\n    function setQuorum(uint _quorum) external onlySelf {\n        quorum = _quorum;\n        emit QuorumUpdated(quorum);\n    }\n    function setQuorumDecayPerSecond(uint _quorumDecayPerSecond) external onlySelf {\n        quorumDecayPerSecond = _quorumDecayPerSecond;\n        emit QuorumDecayPerSecondUpdated(quorumDecayPerSecond);\n    }\n    function setVotingDuration(uint _votingDuration) external onlySelf {\n        votingDuration = _votingDuration;\n        emit VotingDurationUpdated(votingDuration);\n    }\n    function setExecuteDelay(uint _executeDelay) external onlySelf {\n        executeDelay = _executeDelay;\n        emit ExecuteDelayUpdated(executeDelay);\n    }\n    */\n}\n\n/// @notice Optino Governance. (c) The Optino Project 2020\n// SPDX-License-Identifier: GPLv2\ncontract OptinoGov is OptinoGovConfig {\n    using SafeMath for uint;\n\n    struct Commitment {\n        uint64 duration;\n        uint64 end;\n        uint64 lastDelegated;\n        uint64 lastVoted;\n        uint tokens;\n        uint staked;\n        uint votes;\n        uint delegatedVotes;\n        address delegatee;\n    }\n    // Token { dataType 1, address tokenAddress }\n    // Feed { dataType 2, address feedAddress, uint feedType, uint feedDecimals, string name }\n    // Conventions { dataType 3, address [token0, token1], address [feed0, feed1], uint[6] [type0, type1, decimals0, decimals1, inverse0, inverse1], string [feed0Name, feedName2, Market, Convention] }\n    // General { dataType 4, address[4] addresses, address [feed0, feed1], uint[6] uints, string[4] strings }\n    struct StakeInfo {\n        uint dataType;\n        address[4] addresses;\n        uint[6] uints;\n        string string0; // TODO: Check issues using string[4] strings\n        string string1;\n        string string2;\n        string string3;\n    }\n    struct Proposal {\n        uint start;\n        address proposer;\n        string description;\n        address[] targets;\n        uint[] values;\n        string[] signatures;\n        bytes[] data;\n        uint forVotes;\n        uint againstVotes;\n        mapping(address => bool) voted;\n        bool executed;\n    }\n\n    mapping(address => Commitment) public commitments; // Committed tokens per address\n    mapping(address => mapping(bytes32 => uint)) stakes;\n    mapping(bytes32 => StakeInfo) public stakeInfoData;\n    bytes32[] public stakeInfoIndex;\n    uint public proposalCount;\n    mapping(uint => Proposal) public proposals;\n\n    event DelegateUpdated(address indexed oldDelegatee, address indexed delegatee, uint votes);\n    event Committed(address indexed user, uint tokens, uint balance, uint duration, uint end, address delegatee, uint votes, uint rewardPool, uint totalVotes);\n    event StakeInfoAdded(bytes32 stakingKey, uint dataType, address[4] addresses, uint[6] uints, string string0, string string1, string string2, string string3);\n    event Staked(address tokenOwner, uint tokens, uint balance, bytes32 stakingKey);\n    event Unstaked(address tokenOwner, uint tokens, uint balance, bytes32 stakingKey);\n    event StakeBurnt(address tokenOwner, uint tokens, uint balance, bytes32 stakingKey);\n    event Collected(address indexed user, uint elapsed, uint reward, uint callerReward, uint rewardPool, uint end, uint duration);\n    event Uncommitted(address indexed user, uint amount, uint balance, uint duration, uint end, uint votes, uint rewardPool, uint totalVotes);\n    event Proposed(address indexed proposer, uint oip, string description, address[] targets, uint[] value, bytes[] data, uint start);\n    event Voted(address indexed user, uint oip, bool voteFor, uint forVotes, uint againstVotes);\n    event Executed(address indexed user, uint oip);\n\n    constructor(OGTokenInterface ogToken, OGDTokenInterface ogdToken) OptinoGovConfig(ogToken, ogdToken) {\n    }\n\n    function addStakeForToken(uint tokens, address tokenAddress, string memory name) external {\n        bytes32 stakingKey = keccak256(abi.encodePacked(tokenAddress, name));\n        StakeInfo memory stakeInfo = stakeInfoData[stakingKey];\n        if (stakeInfo.dataType == 0) {\n            stakeInfoData[stakingKey] = StakeInfo(1, [tokenAddress, address(0), address(0), address(0)], [uint(0), uint(0), uint(0), uint(0), uint(0), uint(0)], name, \"\", \"\", \"\");\n            stakeInfoIndex.push(stakingKey);\n            emit StakeInfoAdded(stakingKey, 1, [tokenAddress, address(0), address(0), address(0)], [uint(0), uint(0), uint(0), uint(0), uint(0), uint(0)], name, \"\", \"\", \"\");\n        }\n        _addStake(tokens, stakingKey);\n    }\n    function subStakeForToken(uint tokens, address tokenAddress, string calldata name) external {\n        bytes32 stakingKey = keccak256(abi.encodePacked(tokenAddress, name));\n        _subStake(tokens, stakingKey);\n    }\n    function addStakeForFeed(uint tokens, address feedAddress, uint feedType, uint feedDecimals, string calldata name) external {\n        bytes32 stakingKey = keccak256(abi.encodePacked(feedAddress, feedType, feedDecimals, name));\n        StakeInfo memory stakeInfo = stakeInfoData[stakingKey];\n        if (stakeInfo.dataType == 0) {\n            stakeInfoData[stakingKey] = StakeInfo(2, [feedAddress, address(0), address(0), address(0)], [uint(feedType), uint(feedDecimals), uint(0), uint(0), uint(0), uint(0)], name, \"\", \"\", \"\");\n            stakeInfoIndex.push(stakingKey);\n            emit StakeInfoAdded(stakingKey, 2, [feedAddress, address(0), address(0), address(0)], [uint(feedType), uint(feedDecimals), uint(0), uint(0), uint(0), uint(0)], name, \"\", \"\", \"\");\n        }\n        _addStake(tokens, stakingKey);\n    }\n    function subStakeForFeed(uint tokens, address feedAddress, uint feedType, uint feedDecimals, string calldata name) external {\n        bytes32 stakingKey = keccak256(abi.encodePacked(feedAddress, feedType, feedDecimals, name));\n        _subStake(tokens, stakingKey);\n    }\n    function addStakeForConvention(uint tokens, address[4] memory addresses, uint[6] memory uints, string[4] memory strings) external {\n        bytes32 stakingKey = keccak256(abi.encodePacked(addresses, uints, strings[0], strings[1], strings[2], strings[3]));\n        StakeInfo memory stakeInfo = stakeInfoData[stakingKey];\n        if (stakeInfo.dataType == 0) {\n            stakeInfoData[stakingKey] = StakeInfo(3, addresses, uints, strings[0], strings[1], strings[2], strings[3]);\n            stakeInfoIndex.push(stakingKey);\n            emit StakeInfoAdded(stakingKey, 3, addresses, uints, strings[0], strings[1], strings[2], strings[3]);\n        }\n        _addStake(tokens, stakingKey);\n    }\n    function subStakeForConvention(uint tokens, address[4] memory addresses, uint[6] memory uints, string[4] memory strings) external {\n        bytes32 stakingKey = keccak256(abi.encodePacked(addresses, uints, strings[0], strings[1], strings[2], strings[3]));\n        _subStake(tokens, stakingKey);\n    }\n    function addStakeForGeneral(uint tokens, uint dataType, address[4] memory addresses, uint[6] memory uints, string[4] memory strings) external {\n        bytes32 stakingKey = keccak256(abi.encodePacked(addresses, dataType, uints, strings[0], strings[1], strings[2], strings[3]));\n        StakeInfo memory stakeInfo = stakeInfoData[stakingKey];\n        if (stakeInfo.dataType == 0) {\n            stakeInfoData[stakingKey] = StakeInfo(dataType, addresses, uints, strings[0], strings[1], strings[2], strings[3]);\n            stakeInfoIndex.push(stakingKey);\n            emit StakeInfoAdded(stakingKey, dataType, addresses, uints, strings[0], strings[1], strings[2], strings[3]);\n        }\n        _addStake(tokens, stakingKey);\n    }\n    function subStakeForGeneral(uint tokens, uint dataType, address[4] memory addresses, uint[6] memory uints, string[4] memory strings) external {\n        bytes32 stakingKey = keccak256(abi.encodePacked(addresses, dataType, uints, strings[0], strings[1], strings[2], strings[3]));\n        _subStake(tokens, stakingKey);\n    }\n    function _addStake(uint tokens, bytes32 stakingKey) internal {\n        Commitment storage committment = commitments[msg.sender];\n        require(committment.tokens > 0, \"OptinoGov: Commit before staking\");\n        require(committment.tokens >= committment.staked + tokens, \"OptinoGov: Insufficient tokens to stake\");\n        committment.staked = committment.staked.add(tokens);\n        // TODO committment.stakes[stakingKey] = committment.stakes[stakingKey].add(tokens);\n        // TODO emit Staked(msg.sender, tokens, committment.stakes[stakingKey], stakingKey);\n    }\n    function _subStake(uint tokens, bytes32 stakingKey) internal {\n        Commitment storage committment = commitments[msg.sender];\n        require(committment.tokens > 0, \"OptinoGov: Commit and stake tokens before unstaking\");\n        // TODO require(committment.stakes[stakingKey] >= tokens, \"OptinoGov: Insufficient staked tokens\");\n        committment.staked = committment.staked.sub(tokens);\n        // TODO committment.stakes[stakingKey] = committment.stakes[stakingKey].sub(tokens);\n        // TODO emit Unstaked(msg.sender, tokens, committment.stakes[stakingKey], stakingKey);\n    }\n    function stakeInfoLength() public view returns (uint _stakeInfoLength) {\n        _stakeInfoLength = stakeInfoIndex.length;\n    }\n    function getStakeInfoByKey(bytes32 stakingKey) public view returns (uint dataType, address[4] memory addresses, uint[6] memory uints, string memory string0, string memory string1, string memory string2, string memory string3) {\n        StakeInfo memory stakeInfo = stakeInfoData[stakingKey];\n        (dataType, addresses, uints) = (stakeInfo.dataType, stakeInfo.addresses, stakeInfo.uints);\n        string0 = stakeInfo.string0;\n        string1 = stakeInfo.string1;\n        string2 = stakeInfo.string2;\n        string3 = stakeInfo.string3;\n    }\n    function getStaked(address tokenOwner, bytes32 stakingKey) public view returns (uint _staked) {\n        Commitment storage committment = commitments[tokenOwner];\n        // TODO _staked = committment.stakes[stakingKey];\n    }\n\n    function burnStake(address[] calldata tokenOwners, bytes32 stakingKey, uint percent) external onlySelf {\n        for (uint i = 0; i < tokenOwners.length; i++) {\n            address tokenOwner = tokenOwners[i];\n            Commitment storage committment = commitments[tokenOwner];\n            // TODO uint staked = committment.stakes[stakingKey];\n            // if (staked > 0) {\n            //     uint tokensToBurn = staked * percent / uint(100);\n            //     committment.staked = committment.staked.sub(tokensToBurn);\n            //     committment.stakes[stakingKey] = committment.stakes[stakingKey].sub(tokensToBurn);\n            //     committment.tokens = committment.tokens.sub(tokensToBurn);\n            //     require(ogToken.burn(tokensToBurn), \"OptinoGov: burn failed\");\n            //     emit StakeBurnt(tokenOwner, tokensToBurn, committment.stakes[stakingKey], stakingKey);\n            // }\n        }\n    }\n\n    function delegate(address delegatee) public {\n        Commitment storage user = commitments[msg.sender];\n        require(uint(user.lastVoted) + votingDuration < block.timestamp, \"Cannot delegate after recent vote\");\n        address oldDelegatee = user.delegatee;\n        if (user.delegatee != address(0)) {\n            commitments[user.delegatee].delegatedVotes = commitments[user.delegatee].delegatedVotes.sub(user.votes);\n        }\n        user.delegatee = delegatee;\n        user.lastDelegated = uint64(block.timestamp);\n        if (user.delegatee != address(0)) {\n            commitments[user.delegatee].delegatedVotes = commitments[user.delegatee].delegatedVotes.add(user.votes);\n        }\n        emit DelegateUpdated(oldDelegatee, delegatee, user.votes);\n    }\n\n    // Commit OGTokens for some duration. If you already committed some tokens, you cannot set a duration that ends before the current one\n    function commit(uint tokens, uint duration) public {\n        require(duration <= maxDuration, \"duration too long\");\n        Commitment storage user = commitments[msg.sender];\n\n        uint reward = 0;\n        uint oldUserVotes = user.votes;\n        // TODO: Take into account any staked tokens\n        if (user.tokens > 0) {\n            require(block.timestamp + duration >= user.end, \"Cannot shorten duration\");\n\n            // Pay rewards until now and reset\n            uint elapsed = block.timestamp.sub(uint(user.end).sub(user.duration));\n            reward = elapsed.mul(rewardsPerSecond).mul(user.votes).div(totalVotes);\n            if (reward > rewardPool) {\n                reward = rewardPool;\n            }\n            rewardPool = rewardPool.sub(reward);\n            user.tokens = user.tokens.add(reward);\n            emit Collected(msg.sender, elapsed, reward, 0, rewardPool, user.end, user.duration);\n        }\n\n        require(ogToken.transferFrom(msg.sender, address(this), tokens), \"OG transferFrom failed\");\n\n        // Create stake\n        user.tokens = user.tokens.add(tokens);\n        user.duration = uint64(duration);\n        user.end = uint64(block.timestamp.add(duration));\n        user.votes = user.tokens.mul(duration).div(SECONDS_PER_YEAR);\n\n        totalVotes = totalVotes.sub(oldUserVotes).add(user.votes);\n        if (user.delegatee != address(0)) {\n            commitments[user.delegatee].delegatedVotes = commitments[user.delegatee].delegatedVotes.sub(oldUserVotes).add(user.votes);\n        }\n\n        if (reward > 0) {\n            require(ogToken.mint(address(this), reward), \"reward OG mint failed\");\n        }\n        require(ogdToken.mint(msg.sender, tokens.add(reward)), \"commitment + reward OGD mint failed\");\n\n        emit Committed(msg.sender, tokens, user.tokens, user.duration, user.end, user.delegatee, user.votes, rewardPool, totalVotes);\n    }\n\n    function collectRewardFor(address tokenOwner) public {\n        _collectReward(tokenOwner, false, 0);\n    }\n    function collectReward(bool commitRewards, uint duration) public {\n        _collectReward(msg.sender, commitRewards, duration);\n    }\n    function _collectReward(address tokenOwner, bool commitRewards, uint duration) internal {\n        Commitment storage user = commitments[tokenOwner];\n        require(user.tokens > 0);\n\n        // Pay rewards for period = now - beginning = now - (end - duration)\n        uint elapsed = block.timestamp.sub(uint(user.end).sub(user.duration));\n        uint reward = elapsed.mul(rewardsPerSecond).mul(user.votes).div(totalVotes);\n        uint callerReward = 0;\n        if (reward > rewardPool) {\n            reward = rewardPool;\n        }\n        if (reward > 0) {\n            rewardPool = rewardPool.sub(reward);\n            if (msg.sender != tokenOwner) {\n                require(user.end + collectRewardForDelay < block.timestamp, \"Commitment with delay not ended\");\n                callerReward = reward.mul(collectRewardForFee).div(10 ** 18);\n                reward = reward.sub(callerReward);\n            }\n            uint oldUserVotes = user.votes;\n            if (commitRewards) {\n                user.tokens = user.tokens.add(reward);\n                if (user.end < block.timestamp) {\n                    user.end = uint64(block.timestamp);\n                }\n                if (duration > 0) {\n                    require(duration <= maxDuration, \"duration too long\");\n                    user.duration = uint64(duration);\n                    user.end = uint64(block.timestamp.add(duration));\n                } else {\n                    user.duration = uint64(uint(user.end).sub(block.timestamp));\n                }\n                user.votes = user.tokens.mul(user.duration).div(SECONDS_PER_YEAR);\n                require(ogToken.mint(address(this), reward), \"OG mint failed\");\n                require(ogdToken.mint(msg.sender, reward), \"OGD mint failed\");\n            } else {\n                user.duration = uint(user.end) <= block.timestamp ? 0 : uint64(uint(user.end).sub(block.timestamp));\n                user.votes = user.tokens.mul(user.duration).div(SECONDS_PER_YEAR);\n                require(ogToken.mint(tokenOwner, reward), \"OG mint failed\");\n            }\n            totalVotes = totalVotes.sub(oldUserVotes).add(user.votes);\n            if (user.delegatee != address(0)) {\n                commitments[user.delegatee].delegatedVotes = commitments[user.delegatee].delegatedVotes.sub(oldUserVotes).add(user.votes);\n            }\n            if (callerReward > 0) {\n                require(ogToken.mint(msg.sender, callerReward), \"callerReward OG mint failed\");\n            }\n        }\n        emit Collected(msg.sender, elapsed, reward, callerReward, rewardPool, user.end, user.duration);\n    }\n\n    // Unstake all and pay all rewards\n    // TODO\n    function uncommit() public {\n        Commitment storage user = commitments[msg.sender];\n        uint tokens = user.tokens;\n        require(user.tokens > 0);\n        require(block.timestamp > user.end, \"Commitment not ended\");\n\n        // Reward\n        uint elapsed = block.timestamp.sub(uint(user.end).sub(user.duration));\n        uint reward = elapsed.mul(rewardsPerSecond).mul(user.votes).div(totalVotes);\n        rewardPool = rewardPool.sub(reward);\n        user.tokens = user.tokens.add(reward);\n        totalVotes = totalVotes.sub(user.votes);\n        if (user.delegatee != address(0)) {\n            commitments[user.delegatee].delegatedVotes = commitments[user.delegatee].delegatedVotes.sub(user.votes);\n        }\n        user.votes = 0;\n\n        uint payout = user.tokens;\n        user.tokens = 0;\n\n        require(ogToken.transfer(msg.sender, payout), \"OptinoGov: transfer failed\");\n\n        emit Uncommitted(msg.sender, payout, tokens, user.duration, user.end, user.votes, rewardPool, totalVotes);\n    }\n\n    function propose(string memory description, address[] memory targets, uint[] memory values, bytes[] memory data) public returns(uint) {\n        // require(commitments[msg.sender].votes >= totalVotes.mul(proposalThreshold).div(10 ** 18), \"OptinoGov: Not enough votes to propose\");\n\n        proposalCount++;\n        Proposal storage proposal = proposals[proposalCount];\n        proposal.start = block.timestamp;\n        proposal.proposer = msg.sender;\n        proposal.description = description;\n        proposal.targets = targets;\n        proposal.values = values;\n        proposal.data = data;\n        proposal.forVotes = 0;\n        proposal.againstVotes = 0;\n        proposal.executed = false;\n\n        // Proposal memory proposal = Proposal({\n        //     start: block.timestamp,\n        //     proposer: msg.sender,\n        //     description: description,\n        //     targets: [target],\n        //     values: [value],\n        //     data: [data],\n        //     forVotes: 0,\n        //     againstVotes: 0,\n        //     executed: false\n        // });\n\n        // require(token.burnFrom(msg.sender, proposalCost), \"OptinoGov: transferFrom failed\");\n\n        emit Proposed(msg.sender, proposalCount, description, proposal.targets, proposal.values, proposal.data, block.timestamp);\n        return proposalCount;\n    }\n\n    // TODO\n    function vote(uint oip, bool voteFor) public {\n        uint start = proposals[oip].start;\n        require(start != 0 && block.timestamp < start.add(votingDuration), \"Voting closed\");\n        require(commitments[msg.sender].lastDelegated + votingDuration < block.timestamp, \"Cannot vote after recent delegation\");\n        require(!proposals[oip].voted[msg.sender], \"Already voted\");\n        if (voteFor) {\n            proposals[oip].forVotes = proposals[oip].forVotes.add(commitments[msg.sender].votes);\n        }\n        else {\n            proposals[oip].againstVotes = proposals[oip].forVotes.add(commitments[msg.sender].votes);\n        }\n        proposals[oip].voted[msg.sender] = true;\n\n        commitments[msg.sender].lastVoted = uint64(block.timestamp);\n        emit Voted(msg.sender, oip, voteFor, proposals[oip].forVotes, proposals[oip].againstVotes);\n    }\n\n    function voteWithSignatures(bytes32[] calldata signatures) external {\n        // TODO\n    }\n\n    function execute(uint oip) public {\n        Proposal storage proposal = proposals[oip];\n        // require(proposal.start != 0 && block.timestamp >= proposal.start.add(votingDuration).add(executeDelay));\n\n        // if (quorum > currentTime.sub(proposalTime).mul(quorumDecayPerWeek).div(1 weeks)) {\n        //     return quorum.sub(currentTime.sub(proposalTime).mul(quorumDecayPerWeek).div(1 weeks));\n        // } else {\n        //     return 0;\n        // }\n\n        // require(proposal.forVotes >= totalVotes.mul(quorum).div(10 ** 18), \"OptinoGov: Not enough votes to execute\");\n        proposal.executed = true;\n\n        for (uint i = 0; i < proposal.targets.length; i++) {\n            (bool success,) = proposal.targets[i].call{value: proposal.values[i]}(proposal.data[i]);\n            require(success, \"Execution failed\");\n        }\n\n        emit Executed(msg.sender, oip);\n    }\n}\n"
    },
    "contracts/POAPOGTokenStation.sol": {
      "content": "pragma solidity ^0.7.0;\n\n// Use prefix \"./\" normally and \"https://github.com/ogDAO/Governance/blob/master/contracts/\" in Remix\nimport \"./Owned.sol\";\nimport \"./SafeMath.sol\";\nimport \"./OGTokenInterface.sol\";\n\n\n// ----------------------------------------------------------------------------\n// Collect Optino Governance tokens based on POAP tokenEvents\n//\n// Enjoy. (c) The Optino Project 2020\n//\n// SPDX-License-Identifier: GPLv2\n// ----------------------------------------------------------------------------\ninterface POAP {\n    function ownerOf(uint256 tokenId) external view returns (address);\n    function tokenEvent(uint256 tokenId) external view returns (uint256);\n}\n\n\ncontract POAPOGTokenStation is Owned {\n    using SafeMath for uint;\n\n    struct TokenEventData {\n        uint tokensToMint;\n        uint totalCollected;\n        uint numberCollected;\n    }\n\n    OGTokenInterface public ogToken;\n    POAP public poap;\n    // tokenEvents => TokenEvent\n    mapping(uint => TokenEventData) public tokenEventData;\n    // tokenId => amount collected\n    mapping(uint => uint) public collected;\n\n    // POAP @ 0x22C1f6050E56d2876009903609a2cC3fEf83B415 Mainnet,\n    // 0x50C5CA3e7f5566dA3Aa64eC687D283fdBEC2A2F2 Ropsten\n    // POAP Simulator @ 0xb434d03e83706D011398487f158640F0336bb348 Ropsten\n    constructor(OGTokenInterface _ogToken, POAP _poap) {\n        initOwned(msg.sender);\n        ogToken = _ogToken;\n        poap = _poap;\n    }\n\n    function addTokenEvents(uint[] memory _tokenEvents, uint[] memory _tokensToMint) public onlyOwner {\n        require(_tokenEvents.length == _tokensToMint.length);\n        for (uint i = 0; i < _tokenEvents.length; i++) {\n            uint tokenEvent = _tokenEvents[i];\n            tokenEventData[tokenEvent].tokensToMint = _tokensToMint[i];\n        }\n    }\n\n    function collect(uint[] memory tokenIds) public {\n        for (uint i = 0; i < tokenIds.length; i++) {\n            uint tokenId = tokenIds[i];\n            require(msg.sender == poap.ownerOf(tokenId), \"Not owner of POAP token\");\n            uint tokenEvent = poap.tokenEvent(tokenId);\n            TokenEventData storage _tokenEventData = tokenEventData[tokenEvent];\n            uint tokensToMint = _tokenEventData.tokensToMint;\n            if (tokensToMint > collected[tokenId]) {\n                uint newTokens = tokensToMint - collected[tokenId];\n                if (_tokenEventData.totalCollected == 0) {\n                    _tokenEventData.numberCollected++;\n                }\n                _tokenEventData.totalCollected = _tokenEventData.totalCollected.add(newTokens);\n                collected[tokenId] = collected[tokenId].add(newTokens);\n                require(ogToken.mint(msg.sender, newTokens), \"Mint failed\");\n            }\n        }\n    }\n}\n"
    },
    "contracts/TestToken.sol": {
      "content": "pragma solidity ^0.7.0;\n\n// Use prefix \"./\" normally and \"https://github.com/ogDAO/Governance/blob/master/contracts/\" in Remix\nimport \"./Owned.sol\";\nimport \"./SafeMath.sol\";\nimport \"./ERC20.sol\";\n\n// ----------------------------------------------------------------------------\n// Test Token - owner can mint and burn tokens for any account for testing\n//\n// SPDX-License-Identifier: MIT\n//\n// Enjoy.\n//\n// (c) BokkyPooBah / Bok Consulting Pty Ltd 2020. The MIT Licence.\n// ----------------------------------------------------------------------------\n\n\n// ----------------------------------------------------------------------------\n// TestToken = ERC20 with symbol, name & decimals + mint + burn\n// ----------------------------------------------------------------------------\ncontract TestToken is ERC20, Owned {\n    using SafeMath for uint;\n\n    string _symbol;\n    string  _name;\n    uint8 _decimals;\n    uint _totalSupply;\n\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowed;\n\n    constructor(string memory symbol, string memory name, uint8 decimals, address tokenOwner, uint initialSupply) {\n        initOwned(msg.sender);\n        _symbol = symbol;\n        _name = name;\n        _decimals = decimals;\n        balances[tokenOwner] = initialSupply;\n        _totalSupply = initialSupply;\n        emit Transfer(address(0), tokenOwner, _totalSupply);\n    }\n    function symbol() override external view returns (string memory) {\n        return _symbol;\n    }\n    function name() override external view returns (string memory) {\n        return _name;\n    }\n    function decimals() override external view returns (uint8) {\n        return _decimals;\n    }\n    function totalSupply() override external view returns (uint) {\n        return _totalSupply.sub(balances[address(0)]);\n    }\n    function balanceOf(address tokenOwner) override external view returns (uint balance) {\n        return balances[tokenOwner];\n    }\n    function transfer(address to, uint tokens) override external returns (bool success) {\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\n        balances[to] = balances[to].add(tokens);\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n    function approve(address spender, uint tokens) override external returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n    function transferFrom(address from, address to, uint tokens) override external returns (bool success) {\n        balances[from] = balances[from].sub(tokens);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n        balances[to] = balances[to].add(tokens);\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n    function allowance(address tokenOwner, address spender) override external view returns (uint remaining) {\n        return allowed[tokenOwner][spender];\n    }\n    function mint(address tokenOwner, uint tokens) public onlyOwner returns (bool success) {\n        balances[tokenOwner] = balances[tokenOwner].add(tokens);\n        _totalSupply = _totalSupply.add(tokens);\n        emit Transfer(address(0), tokenOwner, tokens);\n        return true;\n    }\n    function burn(address tokenOwner, uint tokens) public onlyOwner returns (bool success) {\n        if (tokens < balances[tokenOwner]) {\n            tokens = balances[tokenOwner];\n        }\n        balances[tokenOwner] = balances[tokenOwner].sub(tokens);\n        _totalSupply = _totalSupply.sub(tokens);\n        emit Transfer(tokenOwner, address(0), tokens);\n        return true;\n    }\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n        return ERC20(tokenAddress).transfer(owner, tokens);\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}